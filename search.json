[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/HW0/index.html",
    "href": "posts/HW0/index.html",
    "title": "HW0",
    "section": "",
    "text": "Introduction and Getting Started\nToday, we’re going to use python to construct an interesting data visualization of the Palmer Penguins dataset. You can read the data into python by running the following code:\n\nimport pandas as pd\nurl = \"https://raw.githubusercontent.com/pic16b-ucla/24W/main/datasets/palmer_penguins.csv\"\npenguins = pd.read_csv(url)\n\nAdditionally, we’re going to want to import both seaborn and matplotlib to create our plots. To do this, run the following code.\n\nimport seaborn as sns \nfrom matplotlib import pyplot as plt\nimport numpy as np\n\n\n\nAnalyzing the Dataset\nNow let’s take a look at the dataset. To get an idea of what it looks like, let’s inspect the first five rows of our penguins DataFrame, using the .head() function as seen below.\n\npenguins.head(5)\n\n\n\n\n\n\n\n\nstudyName\nSample Number\nSpecies\nRegion\nIsland\nStage\nIndividual ID\nClutch Completion\nDate Egg\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nSex\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nComments\n\n\n\n\n0\nPAL0708\n1\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN1A1\nYes\n11/11/07\n39.1\n18.7\n181.0\n3750.0\nMALE\nNaN\nNaN\nNot enough blood for isotopes.\n\n\n1\nPAL0708\n2\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN1A2\nYes\n11/11/07\n39.5\n17.4\n186.0\n3800.0\nFEMALE\n8.94956\n-24.69454\nNaN\n\n\n2\nPAL0708\n3\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN2A1\nYes\n11/16/07\n40.3\n18.0\n195.0\n3250.0\nFEMALE\n8.36821\n-25.33302\nNaN\n\n\n3\nPAL0708\n4\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN2A2\nYes\n11/16/07\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nAdult not sampled.\n\n\n4\nPAL0708\n5\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN3A1\nYes\n11/16/07\n36.7\n19.3\n193.0\n3450.0\nFEMALE\n8.76651\n-25.32426\nNaN\n\n\n\n\n\n\n\nAs we can see, the data holds recorded measurements of Culmen length and depth, flipper length, and body mass, with indentifiers such as the study name, sample number, species, region, island, stage, individual id, clutch completion, egg date, and sex. In all, there 17 columns for each entry.\n\n\nVisualizing the Correlations in the Dataset\nLet’s try and find a correlation between measurements. Take flipper length and body mass. An interesting hypothesis would be that as flipper length increases, so does body mass. Let’s visualize this using a scatterplot. We’ll use seaborn and matplotlib along with the “penguins” dataframe we made earlier. The code is as follows:\n\nsns.scatterplot(data=penguins, x=\"Flipper Length (mm)\", y=\"Body Mass (g)\")\nplt.title(\"Penguin Flipper Length Affect On Body Mass\")\nplt.show\n\n\n\n\n\n\n\n\nWe take data from our penguins DataFrame, specifically from the “Flipper Length (mm)” and “Body Mass (g)” columns. We use seaborn as a shortcut to using matplotlib functions, like scatterplot as above. Pass penguins, “Flipper Length (mm),” and “Body Mass (g)” as arguments to sns.scatterplot. Choose a preferred title, and plot using plt.show. As a further modification, we can add a line of best fit by using sns.regplot, which autofits a line of regression. It’s produced as follows:\n\nsns.regplot(data=penguins, x=\"Flipper Length (mm)\", y=\"Body Mass (g)\", scatter_kws={\"color\":\"blue\"}, line_kws={\"color\":\"red\"})\nplt.title(\"Penguin Flipper Length Affect On Body Mass\")\nplt.show\n\n\n\n\n\n\n\n\nHere, scatter_kws and line_kws are both dictionaries that allow us to change the colors of the datapoints and line of best fit. Body mass and flipper length seem to be directly proportional. This makes sense, since the larger the flipper, the heavier it is, thus increasing body mass."
  },
  {
    "objectID": "posts/HW3/index.html",
    "href": "posts/HW3/index.html",
    "title": "Creating a Simple Message Bank Webapp",
    "section": "",
    "text": "Introduction\nToday we’re going to be making a simple webapp using the very useful python library Flask. To do this, we’ll need to do some work with html, python, and css. For reference, here’s the link to my github repository hosting the work involved in this project: https://github.com/Nkannan12/Message-Bank-Web-App.\n\n\nOur First Method\nNow let’s get into the meat of things by looking at how I implemented a flask application in python. This is seen in the app.py file on github. It starts with the following code, containing import statements and a line to get flask started:\nfrom flask import Flask, g, render_template, request\nimport sqlite3\n\napp = Flask(__name__)\nWe’re giong to use all of these in a bit. Firs up is sqlite3. Look at the first python function in app.py, reproduced below:\ndef get_message_db():\n    try:\n        return g.message_db #check to see if the database exists\n    except:\n        g.message_db = sqlite3.connect(\"message_db.sqlite\") #create database if doesn't exist\n        cmd = \\\n        \"\"\"\n        CREATE TABLE IF NOT EXISTS messages (\n            handle TEXT, \n            message TEXT\n        )\n        \"\"\"\n        with g.message_db:\n            cursor = g.message_db.cursor() \n            cursor.execute(cmd) #creates a table called messages with columns handle and message\n        return g.message_db\nThis function will be used to make (and refer to in the future) a database of the messages submitted through our webapp. It starts by checking whether or not such a database exists (since we don’t want to make a new database for each message, do we), hence the try-except statement. If the database doesn’t exist, it proceeds to the body of the except statement, which creates a new database in the first line. We would like to also record the name of people submitting through the website, so in the following command, we create a table in the database called messages that records the name (handle) and message content of a submission. Finally, we must execute this command, which is done in the body of the with statement. In the end, we return the database for future usage.\n\n\nThe Next Method\nThe next method in app.py allows us to actually record the messages.\ndef insert_message(request):\n    handle = request.form[\"name\"] #extract handle\n    message = request.form[\"message\"] #extract message\n\n    db = get_message_db() #work with database using method from aboe\n    cmd = \\\n    \"\"\"\n    INSERT INTO messages (handle, message) VALUES (?, ?)\n    \"\"\"\n    with db:\n        cursor = db.cursor()\n        cursor.execute(cmd, (handle, message)) #execute cmd, inserting message and handl into table (parametrized)\n        db.commit()\nFirst, we must extract the handle and message content from the request (remeber we imported this in the beginning). The exact sytax required here depends on our html template, which you’ll see later. Next, we initialize a database using the method we just wrote. Then we must make another command using SQL, where we insert parametrized values into the table messages in the database (the ?’s are replaced later with a tuple containing the info we actually want). Finally, we go through a with statement and let a cursor execute our command, subsituting relavent info in the form of a tuple (it should always be a tuple that we insert, even if there’s only one element). To make sure our changes are recorded, we use db.commit().\n\n\nA Method for Returning Random Messages\nWe need to make the webapp interactive, right. To do that, proceed to the next method:\ndef random_messages(n):\n    db = get_message_db()\n    cmd = \\\n    \"\"\"\n    SELECT * FROM messages ORDER BY RANDOM() LIMIT ?\n    \"\"\"\n    with db:\n        cursor = db.cursor()\n        cursor.execute(cmd, (n,))\n        selected_messages = cursor.fetchall() #fethces all responses for future display\n        return selected_messages\nThis one is pretty similar in structure to the other two. Like the previous one, we need to initialize our database, if needed. Then we write an SQL command to select random messages from our database, using SQL’s ORDER BY RANDOM(). Finally, we execute another with statement, letting a cursor select a number of random messages (with their corresponding handle) which is returned to us for further use.\n\n\nHTML: A Brief Interlude\nBefore we dive into the final two python methods, we must first go over the idea of an html template. Navigate to the templates folder on github, and look at base.html, reproduced below:\n\n&lt;!doctype html&gt;\n&lt;link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\"&gt;\n&lt;title&gt;{% block title %}{% endblock %} - Message Bank&lt;/title&gt;\n&lt;nav&gt;\n  &lt;h1&gt;Send Your Messages!&lt;/h1&gt;\n  &lt;!-- &lt;b&gt;Navigation:&lt;/b&gt; --&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=\"{{ url_for('submit') }}\"&gt;Submit a Message&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"{{ url_for('view') }}\"&gt;View a Message&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n&lt;section class=\"content\"&gt;\n  &lt;header&gt;\n    {% block header %}{% endblock %}\n  &lt;/header&gt;\n  {% block content %}{% endblock %}\n&lt;/section&gt;\n\nLooks like a ton of work, but it really isn’t all that much. In this base file, we just organize the layout of everything. As you can see, we’re planning on there being two links on the top of the page you can switch between. We further exted this html template with another one called submit.html, seen below:\n\n{% extends 'base.html' %}\n\n{% block header %}\n    &lt;h1&gt;{% block title %}Submit Your Message{% endblock %}&lt;/h1&gt;\n{% endblock %}\n\n{% block content %}\n    &lt;form method=\"post\"&gt;\n        &lt;label for=\"name\"&gt;What is your name/handle?&lt;/label&gt;\n        &lt;input name=\"name\" id=\"name\"&gt;\n        &lt;br&gt;\n        &lt;label for=\"message\"&gt;Write a message.&lt;/label&gt;\n        &lt;input type=\"text\" name=\"message\" id=\"message\"&gt;\n        &lt;br&gt;\n        &lt;input type=\"submit\" value=\"Submit Message\"&gt;\n    &lt;/form&gt;\n    {% if thanks %}\n        Thanks for the message!\n    {% endif %}\n{% endblock %}\n\nThis one fills in stuff that was left blank in base.html, specifically block header, block title, and block content. This will be the front page of our site, where the user submits their message. I mentioned it before, but you have to be very careful of the syntax here – I’m letting the input of “name” (what the user types in as their handle) be called “name” with id “name”. Similarly, the name of “message” is “message” with id “message”. Then we create a submit button that says “Submit Message” to actually record info. Finally, we end with a nice thank you message that is triggered later on.\n\n\nThe Final Two Methods\nThe final two methods are used to render our html templates. The first renders the submit.html template (which we went over above):\n@app.route('/submit/', methods=['POST', 'GET'])\ndef submit():\n    if request.method == 'GET':\n        return render_template('submit.html', thanks=False)\n    else:\n        insert_message(request)\n        return render_template('submit.html', thanks=True) #makes sure to post response\nAbove the function defintion, @app.route('/submit', methods=['Post', 'Get']) helps define the url for the page submit.html is displayed on. It’s really important that this is right, or your page won’t load. First, we check if request.method == 'GET' to check if it’s an input or output scenario. If true, we just render the template using render_template(), imported above. Otherwise, we need to call the function inser_message(request) so we can actually record the submission. Finally, we trigger the aforementioned “thank you.” The next method renders the view.html template, which we didn’t go over, but is also in the github, in the templates folder:\n@app.route('/view/')\ndef view():\n    messages = random_messages(5) #caps the number of messages shown at 5\n    return render_template('view.html', messages=messages)\nIt’s very similar to def submit(). This is where we showcase the random messages bouncing around in our database, calling the random messages function (I used n=5 here to keep the number of messages popping reasonable), and returning the render template using the render_template() function. Finally,\nif __name__ == \"__main__\":\n    app.run(debug=True, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", 8080)))\nlets us run the whole thing.\n\n\nWhat it Looks Like\nThis is what the submission page looks like. As you can see, it’s just like the submit.html template, with a place to write your name, a place to write your message, and a button to submit.  Here’s what the view message page looks like:  Again, it is all consistent with the template. You can see the message that I put in earlier. I went ahead an typed up four other random ones, and now they’re displayed for you to see."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "myblog",
    "section": "",
    "text": "Creating a Simple Message Bank Webapp\n\n\n\n\n\n\nWeb Development\n\n\nSQL\n\n\nHW\n\n\n\n\n\n\n\n\n\nFeb 21, 2024\n\n\nNarayanan Kannan\n\n\n\n\n\n\n\n\n\n\n\n\nHW0\n\n\n\n\n\n\nweek 0\n\n\nHW\n\n\n\n\n\n\n\n\n\nJan 23, 2024\n\n\nNarayanan Kannan\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 14, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 11, 2024\n\n\nNarayanan Kannan\n\n\n\n\n\n\nNo matching items"
  }
]